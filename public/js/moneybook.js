// Generated by CoffeeScript 1.4.0
(function() {
  var MoneyBook;

  window.MoneyBook = MoneyBook = (function() {

    function MoneyBook(evn, abbrevs) {
      this.evn = evn;
      this.abbrevs = abbrevs;
    }

    MoneyBook.prototype.parse = function(txt) {
      var i, txtLine, txtLines, _i, _len, _results,
        _this = this;
      this.abbrevs = null;
      this.evn = new Event("event");
      this.date = null;
      this.group = null;
      this.currency = 1;
      txtLines = txt.split("\n");
      i = 1;
      _results = [];
      for (_i = 0, _len = txtLines.length; _i < _len; _i++) {
        txtLine = txtLines[_i];
        _results.push((function() {
          _this.parseTxtLine(txtLine, i);
          return i += 1;
        })());
      }
      return _results;
    };

    MoneyBook.prototype.computeSummaryByDate = function() {
      var brain, date, out, value, _fn, _ref,
        _this = this;
      brain = new Brain(this.evn);
      brain.clear();
      brain.compute();
      out = "<pre>";
      _ref = this.evn.days;
      _fn = function() {
        var balance, name, _ref1, _ref2;
        out += "" + date + "\n";
        _ref1 = value.today;
        for (name in _ref1) {
          balance = _ref1[name];
          out += "" + name + ": " + (roundNumber(balance, 2)) + ", spent: " + (roundNumber(value.todaySpent[name], 2)) + ", given: " + (roundNumber(value.todayGiven[name], 2)) + "\n";
        }
        out += "balance:\n";
        _ref2 = value.balance;
        for (name in _ref2) {
          balance = _ref2[name];
          out += "" + name + ": " + (roundNumber(balance, 2)) + ", spent: " + (roundNumber(value.spent[name], 2)) + ", given: " + (roundNumber(value.given[name], 2)) + "\n";
        }
        return out += "\n";
      };
      for (date in _ref) {
        value = _ref[date];
        _fn();
      }
      out += "</pre>";
      return out;
    };

    MoneyBook.prototype.computeSummary = function() {
      var brain, out, p, _fn, _i, _len, _ref,
        _this = this;
      brain = new Brain(this.evn);
      brain.clear();
      brain.compute();
      out = "<pre>";
      _ref = this.evn.people;
      _fn = function() {
        return out += "" + p.name + ": " + (roundNumber(p.balance, 2)) + " (spent: " + (roundNumber(p.spent, 2)) + ", given: " + (roundNumber(p.given, 2)) + ")\n";
      };
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        p = _ref[_i];
        _fn();
      }
      out += "</pre>";
      return out;
    };

    MoneyBook.prototype.parseTxtLine = function(txtLine, line_number) {
      var benPattern, benTxt, benTxts, line, match, name, names, pattern, payrPattern, payrTxt, payrTxts, person, _fn, _fn1, _fn2, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _len6, _m, _n, _o, _ref, _ref1, _ref2,
        _this = this;
      pattern = /^\s*\#\s*.+\s*$/;
      if (pattern.test(txtLine)) {
        line = new Line(txtLine);
        line.string = txtLine;
        line.isComment = true;
        this.evn.lines.push(line);
        return true;
      }
      pattern = /^\s*(\d+(\.\d+)?)\s+([^\#]+)\s*\@\s*([^\#]+)\s*(\#.+)?$/;
      if (pattern.test(txtLine)) {
        match = pattern.exec(txtLine);
        txtLine = "debt (" + match[4] + " " + match[1] + ") " + match[3];
      }
      pattern = /^\s*(\d+(\.\d+)?)\s+([^\#]+)\s*\-+\>\s*([^\#]+)\s*(\#.+)?$/;
      if (pattern.test(txtLine)) {
        match = pattern.exec(txtLine);
        txtLine = "payback (" + match[3] + " " + match[1] + ") " + match[4];
      }
      pattern = /^\s*@\s*people\s*\:\s*([\w\s]+)\s*/;
      if (pattern.test(txtLine)) {
        match = pattern.exec(txtLine);
        names = match[1].split(/\s+/);
        this.abbrevs = abbrev((function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = names.length; _i < _len; _i++) {
            name = names[_i];
            _results.push(name.toLowerCase());
          }
          return _results;
        })());
        for (_i = 0, _len = names.length; _i < _len; _i++) {
          name = names[_i];
          this.evn.people.push(new Person(name));
        }
        line = new Line(txtLine);
        line.isCommand = true;
        this.evn.lines.push(line);
        if (this.group === null) {
          this.group = [];
          _ref = this.evn.people;
          for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
            person = _ref[_j];
            this.group.push(person);
          }
        }
        return true;
      }
      pattern = /^\s*@\s*group\s*\:\s*([\w\s]+)\s*/;
      if (pattern.test(txtLine)) {
        match = pattern.exec(txtLine);
        names = match[1].split(/\s+/);
        this.group = [];
        _fn = function(name) {
          person = _this.getPersonByName(name);
          if (!(person != null)) {
            alert("ERROR: person '" + payrMatch[1] + "' doesn't exist!");
            return false;
          }
          return _this.group.push(person);
        };
        for (_k = 0, _len2 = names.length; _k < _len2; _k++) {
          name = names[_k];
          _fn(name);
        }
        line = new Line(txtLine);
        line.isCommand = true;
        this.evn.lines.push(line);
        return true;
      }
      pattern = /^\s*@\s*no([\s\-]*)*group\s*/;
      if (pattern.test(txtLine)) {
        this.group = [];
        _ref1 = this.evn.people;
        for (_l = 0, _len3 = _ref1.length; _l < _len3; _l++) {
          person = _ref1[_l];
          this.group.push(person);
        }
        line = new Line(txtLine);
        line.isCommand = true;
        this.evn.lines.push(line);
        return true;
      }
      pattern = /^\s*\@\s*date\s*:\s*(.+)\s*$/;
      if (pattern.test(txtLine)) {
        match = pattern.exec(txtLine);
        this.date = match[1].replace(/^\s+|\s+$/g, '');
        line = new Line(txtLine);
        line.string = txtLine;
        line.isCommand = true;
        this.evn.lines.push(line);
        return true;
      }
      pattern = /^\s*\@\s*currency\s*:\s*(.+)\s*$/;
      if (pattern.test(txtLine)) {
        match = pattern.exec(txtLine);
        this.currency = parseFloat(match[1]);
        line = new Line(txtLine);
        line.string = txtLine;
        line.isCommand = true;
        this.evn.lines.push(line);
        return true;
      }
      pattern = /^\s*([\w\ \'\*\%\~]+?)\s*\(\s*(.+)\s*\)\s*([^\#\&]+)?\s*(\&?)\s*(\#.+)?/;
      if (pattern.test(txtLine)) {
        match = pattern.exec(txtLine);
        line = new Line(match[1]);
        payrTxts = match[2].split(/\s+(?=[a-zA-Z])/);
        payrPattern = /([A-Za-z]+)\s*([\d\.]+)/;
        benTxts = match[3] ? match[3].split(/\s+(?=[a-zA-Z])/) : [];
        benPattern = /([A-Za-z]+)(\s+([\d\.\+\-\*\s]+))?/;
        if (match[4] === "&") {
          line.preventDivideAmongOthers = true;
        }
        if (this.currency !== null) {
          line.currency = this.currency;
        }
        line.group = [];
        _ref2 = this.group;
        for (_m = 0, _len4 = _ref2.length; _m < _len4; _m++) {
          person = _ref2[_m];
          line.group.push(person);
        }
        _fn1 = function(payrTxt) {
          var payr, payrMatch;
          payrMatch = payrPattern.exec(payrTxt);
          if (!(payrMatch != null)) {
            alert("ERROR in line " + line_number + ": " + txtLine);
            return false;
          }
          person = _this.getPersonByName(payrMatch[1]);
          if (!(person != null)) {
            alert("ERROR: person '" + payrMatch[1] + "' doesn't exist!");
            return false;
          }
          payr = new Payr(person);
          payr.amount = parseFloat(payrMatch[2] * line.currency);
          return line.payrs.push(payr);
        };
        for (_n = 0, _len5 = payrTxts.length; _n < _len5; _n++) {
          payrTxt = payrTxts[_n];
          _fn1(payrTxt);
        }
        _fn2 = function(benTxt) {
          var ben, benMatch, x;
          benTxt = benTxt.replace(/^\s+|\s+$/g, '');
          benMatch = benPattern.exec(benTxt);
          if (!(benMatch != null)) {
            alert("ERROR in line " + line_number + ": " + txtLine);
            return false;
          }
          person = _this.getPersonByName(benMatch[1]);
          if (!(person != null)) {
            alert("ERROR: person '" + benMatch[1] + "' doesn't exist!");
            return false;
          }
          ben = new Ben(person);
          if (benMatch[3] !== null) {
            if (/^\d+(\.\d+)?$/.test(benMatch[3])) {
              ben.amount = parseFloat(benMatch[3] * line.currency);
            } else {
              if ((x = /[\+\-]\d+(\.\d+)?/.exec(benMatch[3]))) {
                ben.offset = parseFloat(x[0] * line.currency);
              }
              if ((x = /\*(\d+(\.\d+)?)/.exec(benMatch[3]))) {
                ben.multiply = parseFloat(x[1]);
              }
            }
          }
          return line.bens.push(ben);
        };
        for (_o = 0, _len6 = benTxts.length; _o < _len6; _o++) {
          benTxt = benTxts[_o];
          _fn2(benTxt);
        }
        if (this.date !== null) {
          line.date = this.date;
        }
        line.string = txtLine;
        if (line.desc === 'debt' || ~line.desc.indexOf("~")) {
          line.type = 'debt';
        } else if (line.desc === 'payback') {
          line.type = 'payback';
        } else if (line.desc === 'personal') {
          line.type = 'personal';
        } else {
          line.type = 'split';
        }
        if (line.desc.indexOf("*") !== -1) {
          line.shareMissing = true;
        }
        if (line.desc.indexOf("%") !== -1) {
          line.reverse = true;
        }
        this.evn.lines.push(line);
        return true;
      }
      pattern = /^\s*$/;
      if (!pattern.test(txtLine)) {
        alert("SYNTAX ERROR IN LINE: " + txtLine);
      }
      return false;
    };

    MoneyBook.prototype.getPersonByName = function(name) {
      var out, person, _fn, _i, _len, _ref,
        _this = this;
      out = null;
      name = this.abbrevs[name.toLowerCase()];
      if (name === void 0) {
        return null;
      }
      _ref = this.evn.people;
      _fn = function(person) {
        if (out !== null) {
          return false;
        }
        if (person.name.toLowerCase() === name.toLowerCase()) {
          return out = person;
        }
      };
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        person = _ref[_i];
        _fn(person);
      }
      return out;
    };

    return MoneyBook;

  })();

}).call(this);
